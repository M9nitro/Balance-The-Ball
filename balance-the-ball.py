# -*- coding: utf-8 -*-
"""423final.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1YK33Ha99P0e-7-KLqNUmXgbRGQHJqB6i
"""

from OpenGL.GL import *
from OpenGL.GLUT import *
from OpenGL.GLU import *
import random, math

player_score = 0

# Core coordinates and dimensions
screen_width = 810
screen_height = 810

# Ball properties
ball_x = 0
ball_y = 50
ball_radius = 4
ball_speed = 0.1
ball_on_line = None

# Enviroment Properties
gravity = 0.001 # Gravity Constant
wind = 0.1 # Wind Constant
is_dark_mode = True

# Line properties
lines = []
COLORS = [
    (1.0, 0.0, 0.0),  # Red
    (0.0, 1.0, 0.0),  # Green
    (0.0, 0.0, 1.0),  # Blue

]
LINE_THICKNESS = 3
LINE_SPEED = 0.1
LINE_LENGTH = 50
MIN_LINE_LENGTH = 23
MAX_LINE_LENGTH = 60

# Game state
is_game_over = False
is_game_paused = False

# Add after other global variables
particles = []
PARTICLE_COUNT = 100
PARTICLE_LIFETIME = 60  # frames

class Particle:
    def __init__(self, x, y):
        self.x = x
        self.y = y
        angle = random.uniform(0, 2 * math.pi)
        speed = random.uniform(0.5, 2.0)
        self.dx = speed * math.cos(angle)
        self.dy = speed * math.sin(angle)
        self.lifetime = PARTICLE_LIFETIME

# Drawing functions

def draw_point(x, y, intensity, is_border=False):
    if is_border:
        glColor3f(0.0, 0.0, 0.0) if not is_dark_mode else glColor3f(1.0, 1.0, 1.0)
    else:
        glColor3f(1.0, 0.0, 0.0)  # Keep ball red
    glVertex2f(x, y)

def draw_circle(radius, center_x, center_y, intensity):
    x = 0
    y = radius
    decision = 1 - radius

    # Fill circle interior first (red)
    for yi in range(-radius, radius + 1):
        xi = int((radius * radius - yi * yi) ** 0.5)
        for xi_fill in range(-xi, xi + 1):
            draw_point(center_x + xi_fill, center_y + yi, intensity, False)

    # Draw circle outline points (white)
    draw_point(x + center_x, y + center_y, intensity, True)
    if radius > 0:
        draw_point(x + center_x, -y + center_y, intensity, True)
        draw_point(-x + center_x, y + center_y, intensity, True)
        draw_point(-x + center_x, -y + center_y, intensity, True)

    while x < y:
        x += 1
        if decision <= 0:
            decision = decision + 2*x + 1
        else:
            y -= 1
            decision = decision + (2*x - 2*y) + 1
        if x > y:
            break

        # Draw remaining outline points (white)
        draw_point(x + center_x, y + center_y, intensity, True)
        draw_point(x + center_x, -y + center_y, intensity, True)
        draw_point(-x + center_x, y + center_y, intensity, True)
        draw_point(-x + center_x, -y + center_y, intensity, True)

        if x != y:
            draw_point(y + center_x, x + center_y, intensity, True)
            draw_point(y + center_x, -x + center_y, intensity, True)
            draw_point(-y + center_x, x + center_y, intensity, True)
            draw_point(-y + center_x, -x + center_y, intensity, True)

def draw_line(start_x, start_y, end_x, end_y):
    dx = abs(end_x - start_x)
    dy = abs(end_y - start_y)
    x = start_x
    y = start_y
    x_step = 1 if (start_x < end_x) else -1
    y_step = 1 if (start_y < end_y) else -1

    if dx > dy:
        p = 2*dy - dx
        for _ in range(dx + 1):
            glVertex2f(x, y)
            if p >= 0:
                y += y_step
                p -= 2*dx
            x += x_step
            p += 2*dy
    else:
        p = 2*dx - dy
        for _ in range(dy + 1):
            glVertex2f(x, y)
            if p >= 0:
                x += x_step
                p -= 2*dy
            y += y_step
            p += 2*dx

def create_explosion(x, y):
    global particles
    particles = [Particle(x, y) for _ in range(PARTICLE_COUNT)]

def update_particles():
    global particles
    for p in particles[:]:
        p.x += p.dx
        p.y += p.dy
        p.lifetime -= 1
        if p.lifetime <= 0:
            particles.remove(p)

def draw_particles():
    if particles:
        glPointSize(2)
        glBegin(GL_POINTS)
        for p in particles:
            intensity = p.lifetime / PARTICLE_LIFETIME
            glColor3f(1.0 * intensity, 0.0, 0.0)
            glVertex2f(p.x, p.y)
        glEnd()

def update_ball():
    global ball_x, ball_y, ball_speed, ball_on_line, gravity, is_game_over, player_score
    if not is_game_paused:
        current_line = check_ball_line_collision()

        if current_line:
            # Keep ball on line by matching speeds exactly
            ball_on_line = current_line
            ball_y = current_line['y'] + ball_radius
            ball_speed = LINE_SPEED  # Match line speed exactly
        else:
            # Ball is falling
            ball_on_line = None
            ball_speed += gravity
            ball_y -= ball_speed

        # Move ball up with line if on one
        if ball_on_line:
            ball_y += LINE_SPEED  # Use exact line speed

        # Boundary checks...
        if (ball_x < -80 or ball_x > 80 or
            ball_y < -80 or ball_y > 80):
            is_game_over = True
            print('Game Over! Ball went outside window')
            print('Final Score:', player_score)
            create_explosion(ball_x, ball_y)

def check_ball_line_collision():
    global ball_on_line
    ball_bottom = ball_y - ball_radius
    for line in lines:
        if (line['y'] <= ball_bottom <= line['y'] + LINE_THICKNESS and
            line['x1'] - ball_radius <= ball_x <= line['x2'] + ball_radius):
            return line
    return None

def generate_line():
    """Generate horizontal line with random length and color"""
    y = -80
    line_length = random.randint(MIN_LINE_LENGTH, MAX_LINE_LENGTH)
    x1 = random.randint(-120, 120 - line_length)
    x2 = x1 + 20
    return {
        'x1': x1,
        'x2': x2,
        'y': y,
        'color': random.choice(COLORS)
    }

def update_lines():
    global lines, player_score, is_game_over, ball_x, ball_y
    for line in lines[:]:
        line['y'] += LINE_SPEED

        # Check for red line collision
        if line['color'] == (1.0, 0.0, 0.0):  # Red line
            if line == check_ball_line_collision():  # If ball is touching this red line
                is_game_over = True
                lines.clear()
                print('Game Over! Ball hit red line')
                print('Final Score:', player_score)
                create_explosion(ball_x, ball_y)
                return  # Exit immediately when red line is hit

        if line['y'] > 65:
            # Add score when line exits top
            if line['color'] == (0.0, 1.0, 0.0):  # Green line
                player_score += 10
            elif line['color'] == (0.0, 0.0, 1.0):  # Blue line
                player_score += 5
            lines.remove(line)

def draw_thick_line(x1, x2, y, color):
    """Draw colored horizontal line with thickness"""
    glColor3f(*color)  # Unpack RGB values
    for offset in range(LINE_THICKNESS):
        draw_line(x1, y + offset, x2, y + offset)

def handle_keyboard(key, x, y):
    global ball_x, ball_y, is_game_paused, is_dark_mode, player_score
    if key == b'p':  # Handle pause regardless of current state
        is_game_paused = not is_game_paused
        print("Game", "Paused" if is_game_paused else "Resumed")
    elif key == b'l':  # Toggle dark/light mode
        is_dark_mode = not is_dark_mode
        set_background_mode()
    elif not is_game_paused:  # Only handle movement when not paused
        if key == b'a':
            ball_x = max(ball_x - 3, -225)
        elif key == b'd':
            ball_x = min(ball_x + 3, 225)
        elif key == b'w' and ball_on_line:
            ball_y = min(ball_y + 1, 80)
        elif key == b's':
            ball_y = max(ball_y - 1, -80)
        elif key == b' ':
            ball_y = max(ball_y + 13, -80)
        elif key == b'r':
            reset_game()
        elif key == b'q':
            print('Goodbye! Final Score:', player_score)
            glutLeaveMainLoop()
    glutPostRedisplay()

def handle_mouse(button, state, x, y):
    global is_game_paused, player_score
    if button == GLUT_LEFT_BUTTON and state == GLUT_DOWN:
        # Combining mouse coordinate conversion here
        x = x - (screen_width//2)
        y = (screen_height//2)-y
    if 350 <= x <= 400 and 350 <= y <= 400:
        print('Goodbye! Final Score:', player_score)
        glutLeaveMainLoop()
    if -30 <= x <= 30 and 350 <= y <= 400:
        if is_game_paused:
            is_game_paused = False
            print('Game Resumed!')
        else:
            is_game_paused = True
            print('Game Paused!')
    if -400 <= x <= -350 and 350 <= y <= 400:
        print('Starting Over!')
        is_game_paused = False
        reset_game()

def reset_game():
    global ball_x, ball_y, player_score, is_game_over, lines, ball_speed, ball_on_line
    # Reset ball
    ball_x = 0
    ball_y = 50
    ball_speed = 0.1
    ball_on_line = None

    # Reset game state
    player_score = 0
    is_game_over = False

    # Reset and initialize lines
    lines.clear()
    # Add initial line
    lines.append(generate_line())

def scene():
    glClear(GL_COLOR_BUFFER_BIT)
    glMatrixMode(GL_MODELVIEW)
    glLoadIdentity()
    gluLookAt(0, 0, 200, 0, 0, 0, 0, 1, 0)
    # Draw lines
    glPointSize(2)
    glBegin(GL_POINTS)
    for line in lines:
        draw_thick_line(line['x1'], line['x2'], line['y'], line['color'])
    glEnd()
    # Draw ball
    glPointSize(5)
    glBegin(GL_POINTS)
    draw_circle(ball_radius, ball_x, ball_y, 1)
    glEnd()
    if particles:
        draw_particles()
    # Draw score
    glColor3f(1.0, 1.0, 1.0)
    draw_exit_cross()
    draw_pause_button()
    draw_restart_button()
    glutSwapBuffers()

# timers
def animation_timer(value):
    if not is_game_over:
        if not is_game_paused:
            update_ball()
            update_lines()
            update_particles()  # Add particle updates
            if random.random() < 0.005:
                lines.append(generate_line())
        glutPostRedisplay()
    glutTimerFunc(20, animation_timer, 0)

def set_background_mode():
    if is_dark_mode:
        glClearColor(0, 0, 0, 0)  # Black background
    else:
        glClearColor(1, 1, 1, 0)  # White background

def init_game():
    set_background_mode()
    glMatrixMode(GL_PROJECTION)
    glLoadIdentity()
    aspect = screen_width / screen_height
    gluPerspective(45, aspect, 0.1, 1000.0)

def draw_exit_cross():
    glColor3f(1, 0, 0)
    glPointSize(5)
    glBegin(GL_POINTS)
    draw_line(70,80,80,70)
    draw_line(70,70,80,80)
    glEnd()

def draw_pause_button():
    global is_game_paused
    glColor3f(1, 1, 0)
    glPointSize(5)
    glBegin(GL_POINTS)
    if is_game_paused:
        draw_line(-5, 70, -5, 80)
        draw_line(-5, 70, 5, 75)
        draw_line(5, 75, -5, 80)
    else:
        draw_line(5, 70, 5, 80)
        draw_line(-5, 70, -5, 80)
    glEnd()

def draw_restart_button():
    glColor3f(0, 1,0)
    glPointSize(5)
    glBegin(GL_POINTS)
    draw_line(-70, 75, -80, 75)
    draw_line(-80, 75, -70, 80)
    draw_line(-80, 75, -70, 70)
    glEnd()

# Main program
glutInit()
glutInitWindowSize(screen_width, screen_height)
glutInitWindowPosition(0, 0)
glutInitDisplayMode(GLUT_DEPTH | GLUT_DOUBLE | GLUT_RGB)
glutCreateWindow(b"Ball Game")
init_game()
glutDisplayFunc(scene)
glutKeyboardFunc(handle_keyboard)
glutMouseFunc(handle_mouse)
glutTimerFunc(0, animation_timer, 0)
glutMainLoop()